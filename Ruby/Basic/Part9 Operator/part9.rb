# Session 1 赋值运算符

# =	简单的赋值运算符，把右操作数的值赋给左操作数	c = a + b 将把 a + b 的值赋给 c
# +=	加且赋值运算符，把右操作数加上左操作数的结果赋值给左操作数	c += a 相当于 c = c + a
# -=	减且赋值运算符，把左操作数减去右操作数的结果赋值给左操作数	c -= a 相当于 c = c - a
# *=	乘且赋值运算符，把右操作数乘以左操作数的结果赋值给左操作数	c *= a 相当于 c = c * a
# /=	除且赋值运算符，把左操作数除以右操作数的结果赋值给左操作数	c /= a 相当于 c = c / a
# %=	求模且赋值运算符，求两个操作数的模赋值给左操作数	c %= a 相当于 c = c % a
# **=	指数且赋值运算符，执行指数计算，并赋值给左操作数	c **= a 相当于 c = c ** a

# Session 2 逻辑运算符

# and	称为逻辑与运算符。如果两个操作数都为真，则条件为真。	(a and b) 为真。
# or	称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。	(a or b) 为真。
# &&	称为逻辑与运算符。如果两个操作数都非零，则条件为真。	(a && b) 为真。
# ||	称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。	(a || b) 为真。
# !	称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。	!(a && b) 为假。
# not	称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。	not(a && b) 为假。

# Session 3 三元运算符
# 有一个以上的操作称为三元运算符。
# 第一个计算表达式的真假值，然后根据这个结果决定执行后边两个语句中的一个。条件运算符的语法如下：
# ? :	条件表达式	如果条件为真 ? 则值为 X : 否则值为 Y

# Session 4 范围运算符
# 
# ..	创建一个从开始点到结束点的范围（包含结束点）	1..10 创建从 1 到 10 的范围
# ...	创建一个从开始点到结束点的范围（不包含结束点）	1...10 创建从 1 到 9 的范围
# 
# Range.new(1, 10) 与 1..10 含义相同

# 如果数值以外的对象也实现了根据当前值生成下一个值的方法,那么通过指定范围的起点与终点就可以生成 Range 对象。例如,我们可以用字符串对象生成
# Range 对象。
p ("a".."f").to_a
p ("a"..."f").to_a
#=> ["a", "b", "c", "d", "e", "f"]

# Session 5 运算符的优先级
# 下表按照运算符的优先级从高到低列出了所有的运算符。

# 方 法	        运算符	                        描述
#  是         [ ] [ ]=                      元素引用、元素集合
#  是	        ::	                        常量解析运算符
#  是	        **	                        指数
#  是	        ! ~ + -	                    非、补、一元加、一元减（最后两个的方法名为 +@ 和 -@）
#  是	      * / %	                        乘法、除法、求模
#  是	        + -	                        加法和减法
#  是	        >> <<	                    位右移、位左移
#  是	        &	                        位与
#  是	        ^ |	                        位异或、位或
#  是	         <= < > >=	                比较运算符
#  是	    <=> == === != =~ !~	            相等和模式匹配运算符（!= 和 !~ 不能被定义为方法）
#  否            &&	                        逻辑与
#  否            ||	                        逻辑或
#  否           .. ...	                    范围（包含、不包含）
#  否           ? :	                        三元 if-then-else
#  否         = %= { /= -= += 
#            |= &= >>= <<= *= 
#            &&= ||= **=	                赋值
#  否         defined?	                    检查指定符号是否已定义
#  否         not	                        逻辑否定
#  否         or and	                    逻辑组成

# 注意：在方法列标识为 “是” 的运算符实际上是方法，因此可以被重载。
# 如果不想按照优先级的顺序进行计算,可以用 () 将希望优先计算的部分括起来,当有多个 () 时,
# 则从最内侧的 () 开始算起。因此,如果还未能熟练掌握
# 运算符的优先顺序,建议多使用 () 。

# Session 6 定义运算符

# 一元运算符
# 定义四则运算符等二元运算符时,会将运算符名作为方法名,按照定义方法的做法重定义运算符。
# 运算符的左侧为接收者,右侧被作为方法的参数传递。
# eg. point_operator
#   为表示二元坐标的 Point 类定义运算符 + 以及 - 。

# 一元运算符
# 可定义的一元运算符有 + 、- 、~ 、! 4 个。
# 它们分别以 +@ 、 -@ 、 ~@ 、 !@ 为方法名进行方法的定义。这里需要注意的是,一元运算符都是没有参数的。
# eg. point_operator

# 下标方法
# 数组、散列中的 obj[ i ] 以及 obj[ i ]= x 这样的方法,称为下标方法。定义下标方法时的方法名分别为 [] 和 []= 。
# eg. point_operator
#   定义 Point类实例 pt 的下标方法,实现以 v[0] 的形式访问 pt.x ,以 v[1] 的形式访问 pt.y 。

# Session 7 位运算符

# &	如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。	(a & b) 将得到 12，即为 0000 1100
# |	如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。	(a | b) 将得到 61，即为 0011 1101
# ^	如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。	(a ^ b) 将得到 49，即为 0011 0001
# ~	二进制补码运算符是一元运算符，具有"翻转"位效果。	(~a ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。
# <<	二进制左移运算符。左操作数的值向左移动右操作数指定的位数。	a << 2 将得到 240，即为 1111 0000
# >>	二进制右移运算符。左操作数的值向右移动右操作数指定的位数。	a >> 2 将得到 15，即为 0000 1111